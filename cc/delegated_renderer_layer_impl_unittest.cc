// Copyright 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "cc/delegated_renderer_layer_impl.h"

#include "cc/append_quads_data.h"
#include "cc/layer_tree_host_impl.h"
#include "cc/layer_tree_impl.h"
#include "cc/quad_sink.h"
#include "cc/render_pass_draw_quad.h"
#include "cc/scoped_ptr_vector.h"
#include "cc/single_thread_proxy.h"
#include "cc/solid_color_draw_quad.h"
#include "cc/solid_color_layer_impl.h"
#include "cc/test/fake_layer_tree_host_impl.h"
#include "cc/test/fake_layer_tree_host_impl_client.h"
#include "cc/test/fake_output_surface.h"
#include "cc/test/fake_proxy.h"
#include "cc/test/fake_web_graphics_context_3d.h"
#include "cc/test/geometry_test_utils.h"
#include "cc/test/mock_quad_culler.h"
#include "cc/test/render_pass_test_common.h"
#include "cc/test/render_pass_test_utils.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "ui/gfx/transform.h"

namespace cc {
namespace {

class DelegatedRendererLayerImplTest : public testing::Test {
public:
    DelegatedRendererLayerImplTest()
        : m_proxy(scoped_ptr<Thread>(NULL))
        , m_alwaysImplThreadAndMainThreadBlocked(&m_proxy)
    {
        LayerTreeSettings settings;
        settings.minimumOcclusionTrackingSize = gfx::Size();

        m_hostImpl = LayerTreeHostImpl::create(settings, &m_client, &m_proxy);
        m_hostImpl->initializeRenderer(createFakeOutputSurface());
        m_hostImpl->setViewportSize(gfx::Size(10, 10), gfx::Size(10, 10));
    }

protected:
    FakeProxy m_proxy;
    FakeLayerTreeHostImplClient m_client;
    DebugScopedSetImplThreadAndMainThreadBlocked m_alwaysImplThreadAndMainThreadBlocked;
    scoped_ptr<LayerTreeHostImpl> m_hostImpl;
};

class DelegatedRendererLayerImplTestSimple : public DelegatedRendererLayerImplTest {
public:
    DelegatedRendererLayerImplTestSimple()
        : DelegatedRendererLayerImplTest()
    {
        scoped_ptr<LayerImpl> rootLayer = SolidColorLayerImpl::create(m_hostImpl->activeTree(), 1).PassAs<LayerImpl>();
        scoped_ptr<LayerImpl> layerBefore = SolidColorLayerImpl::create(m_hostImpl->activeTree(), 2).PassAs<LayerImpl>();
        scoped_ptr<LayerImpl> layerAfter = SolidColorLayerImpl::create(m_hostImpl->activeTree(), 3).PassAs<LayerImpl>();
        scoped_ptr<DelegatedRendererLayerImpl> delegatedRendererLayer = DelegatedRendererLayerImpl::create(m_hostImpl->activeTree(), 4);

        m_hostImpl->setViewportSize(gfx::Size(100, 100), gfx::Size(100, 100));
        rootLayer->setBounds(gfx::Size(100, 100));

        layerBefore->setPosition(gfx::Point(20, 20));
        layerBefore->setBounds(gfx::Size(14, 14));
        layerBefore->setContentBounds(gfx::Size(14, 14));
        layerBefore->setDrawsContent(true);
        layerBefore->setForceRenderSurface(true);

        layerAfter->setPosition(gfx::Point(5, 5));
        layerAfter->setBounds(gfx::Size(15, 15));
        layerAfter->setContentBounds(gfx::Size(15, 15));
        layerAfter->setDrawsContent(true);
        layerAfter->setForceRenderSurface(true);

        delegatedRendererLayer->setPosition(gfx::Point(3, 3));
        delegatedRendererLayer->setBounds(gfx::Size(10, 10));
        delegatedRendererLayer->setContentBounds(gfx::Size(10, 10));
        delegatedRendererLayer->setDrawsContent(true);
        gfx::Transform transform;
        transform.Translate(1, 1);
        delegatedRendererLayer->setTransform(transform);

        ScopedPtrVector<RenderPass> delegatedRenderPasses;
        TestRenderPass* pass1 = addRenderPass(delegatedRenderPasses, RenderPass::Id(9, 6), gfx::Rect(6, 6, 6, 6), gfx::Transform());
        addQuad(pass1, gfx::Rect(0, 0, 6, 6), 33u);
        TestRenderPass* pass2 = addRenderPass(delegatedRenderPasses, RenderPass::Id(9, 7), gfx::Rect(7, 7, 7, 7), gfx::Transform());
        addQuad(pass2, gfx::Rect(0, 0, 7, 7), 22u);
        addRenderPassQuad(pass2, pass1);
        TestRenderPass* pass3 = addRenderPass(delegatedRenderPasses, RenderPass::Id(9, 8), gfx::Rect(0, 0, 8, 8), gfx::Transform());
        addRenderPassQuad(pass3, pass2);
        delegatedRendererLayer->setRenderPasses(delegatedRenderPasses);

        // The RenderPasses should be taken by the layer.
        EXPECT_EQ(0u, delegatedRenderPasses.size());

        m_rootLayerPtr = rootLayer.get();
        m_layerBeforePtr = layerBefore.get();
        m_layerAfterPtr = layerAfter.get();
        m_delegatedRendererLayerPtr = delegatedRendererLayer.get();

        // Force the delegated RenderPasses to come before the RenderPass from layerAfter.
        layerAfter->addChild(delegatedRendererLayer.PassAs<LayerImpl>());
        rootLayer->addChild(layerAfter.Pass());

        // Get the RenderPass generated by layerBefore to come before the delegated RenderPasses.
        rootLayer->addChild(layerBefore.Pass());

        m_hostImpl->activeTree()->SetRootLayer(rootLayer.Pass());
    }

protected:
    LayerImpl* m_rootLayerPtr;
    LayerImpl* m_layerBeforePtr;
    LayerImpl* m_layerAfterPtr;
    DelegatedRendererLayerImpl* m_delegatedRendererLayerPtr;
};

TEST_F(DelegatedRendererLayerImplTestSimple, AddsContributingRenderPasses)
{
    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes.
    ASSERT_EQ(5u, frame.renderPasses.size());

    // The DelegatedRendererLayer should have added its contributing RenderPasses to the frame.
    EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
    EXPECT_EQ(1, frame.renderPasses[1]->id.index);
    EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
    EXPECT_EQ(2, frame.renderPasses[2]->id.index);
    // And all other RenderPasses should be non-delegated.
    EXPECT_NE(4, frame.renderPasses[0]->id.layer_id);
    EXPECT_EQ(0, frame.renderPasses[0]->id.index);
    EXPECT_NE(4, frame.renderPasses[3]->id.layer_id);
    EXPECT_EQ(0, frame.renderPasses[3]->id.index);
    EXPECT_NE(4, frame.renderPasses[4]->id.layer_id);
    EXPECT_EQ(0, frame.renderPasses[4]->id.index);

    // The DelegatedRendererLayer should have added its RenderPasses to the frame in order.
    EXPECT_RECT_EQ(gfx::Rect(6, 6, 6, 6), frame.renderPasses[1]->output_rect);
    EXPECT_RECT_EQ(gfx::Rect(7, 7, 7, 7), frame.renderPasses[2]->output_rect);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestSimple, AddsQuadsToContributingRenderPasses)
{
    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes.
    ASSERT_EQ(5u, frame.renderPasses.size());

    // The DelegatedRendererLayer should have added its contributing RenderPasses to the frame.
    EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
    EXPECT_EQ(1, frame.renderPasses[1]->id.index);
    EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
    EXPECT_EQ(2, frame.renderPasses[2]->id.index);

    // The DelegatedRendererLayer should have added copies of its quads to contributing RenderPasses.
    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
    EXPECT_RECT_EQ(gfx::Rect(0, 0, 6, 6), frame.renderPasses[1]->quad_list[0]->rect);

    // Verify it added the right quads.
    ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
    EXPECT_RECT_EQ(gfx::Rect(0, 0, 7, 7), frame.renderPasses[2]->quad_list[0]->rect);
    EXPECT_RECT_EQ(gfx::Rect(6, 6, 6, 6), frame.renderPasses[2]->quad_list[1]->rect);
    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
    EXPECT_RECT_EQ(gfx::Rect(0, 0, 6, 6), frame.renderPasses[1]->quad_list[0]->rect);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestSimple, AddsQuadsToTargetRenderPass)
{
    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes.
    ASSERT_EQ(5u, frame.renderPasses.size());

    // The layer's target is the RenderPass from m_layerAfter.
    EXPECT_EQ(RenderPass::Id(3, 0), frame.renderPasses[3]->id);

    // The DelegatedRendererLayer should have added copies of quads in its root RenderPass to its target RenderPass.
    // The m_layerAfter also adds one quad.
    ASSERT_EQ(2u, frame.renderPasses[3]->quad_list.size());

    // Verify it added the right quads.
    EXPECT_RECT_EQ(gfx::Rect(7, 7, 7, 7), frame.renderPasses[3]->quad_list[0]->rect);

    // Its target layer should have a quad as well.
    EXPECT_RECT_EQ(gfx::Rect(0, 0, 15, 15), frame.renderPasses[3]->quad_list[1]->rect);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestSimple, QuadsFromRootRenderPassAreModifiedForTheTarget)
{
    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes.
    ASSERT_EQ(5u, frame.renderPasses.size());

    // The DelegatedRendererLayer is at position 3,3 compared to its target, and has a translation transform of 1,1.
    // So its root RenderPass' quads should all be transformed by that combined amount.
    // The DelegatedRendererLayer has a size of 10x10, but the root delegated RenderPass has a size of 8x8, so
    // any quads should be scaled by 10/8.
    gfx::Transform transform;
    transform.Translate(4.0, 4.0);
    transform.Scale(10.0 / 8.0, 10.0 / 8.0);
    EXPECT_TRANSFORMATION_MATRIX_EQ(transform, frame.renderPasses[3]->quad_list[0]->quadTransform());

    // Quads from non-root RenderPasses should not be shifted though.
    ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[2]->quad_list[0]->quadTransform());
    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[2]->quad_list[1]->quadTransform());
    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[1]->quad_list[0]->quadTransform());

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestSimple, DoesNotOwnARenderSurface)
{
    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    // If the DelegatedRendererLayer is axis aligned and has opacity 1, then
    // it has no need to be a renderSurface for the quads it carries.
    EXPECT_FALSE(m_delegatedRendererLayerPtr->renderSurface());

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestSimple, DoesOwnARenderSurfaceForOpacity)
{
    m_delegatedRendererLayerPtr->setOpacity(0.5f);

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    // This test case has quads from multiple layers in the delegated renderer,
    // so if the DelegatedRendererLayer has opacity < 1, it should end up with
    // a render surface.
    EXPECT_TRUE(m_delegatedRendererLayerPtr->renderSurface());

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestSimple, DoesOwnARenderSurfaceForTransform)
{
    gfx::Transform rotation;
    rotation.RotateAboutZAxis(30.0);
    m_delegatedRendererLayerPtr->setTransform(rotation);

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    // This test case has quads from multiple layers in the delegated renderer,
    // so if the DelegatedRendererLayer has opacity < 1, it should end up with
    // a render surface.
    EXPECT_TRUE(m_delegatedRendererLayerPtr->renderSurface());

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

class DelegatedRendererLayerImplTestOwnSurface : public DelegatedRendererLayerImplTestSimple {
public:
    DelegatedRendererLayerImplTestOwnSurface()
        : DelegatedRendererLayerImplTestSimple()
    {
        m_delegatedRendererLayerPtr->setForceRenderSurface(true);
    }
};

TEST_F(DelegatedRendererLayerImplTestOwnSurface, AddsRenderPasses)
{
    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes and its owned surface added one pass.
    ASSERT_EQ(6u, frame.renderPasses.size());

    // The DelegatedRendererLayer should have added its contributing RenderPasses to the frame.
    EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
    EXPECT_EQ(1, frame.renderPasses[1]->id.index);
    EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
    EXPECT_EQ(2, frame.renderPasses[2]->id.index);
    // The DelegatedRendererLayer should have added a RenderPass for its surface to the frame.
    EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
    EXPECT_EQ(0, frame.renderPasses[3]->id.index);
    // And all other RenderPasses should be non-delegated.
    EXPECT_NE(4, frame.renderPasses[0]->id.layer_id);
    EXPECT_EQ(0, frame.renderPasses[0]->id.index);
    EXPECT_NE(4, frame.renderPasses[4]->id.layer_id);
    EXPECT_EQ(0, frame.renderPasses[4]->id.index);
    EXPECT_NE(4, frame.renderPasses[5]->id.layer_id);
    EXPECT_EQ(0, frame.renderPasses[5]->id.index);

    // The DelegatedRendererLayer should have added its RenderPasses to the frame in order.
    EXPECT_RECT_EQ(gfx::Rect(6, 6, 6, 6), frame.renderPasses[1]->output_rect);
    EXPECT_RECT_EQ(gfx::Rect(7, 7, 7, 7), frame.renderPasses[2]->output_rect);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestOwnSurface, AddsQuadsToContributingRenderPasses)
{
    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes and its owned surface added one pass.
    ASSERT_EQ(6u, frame.renderPasses.size());

    // The DelegatedRendererLayer should have added its contributing RenderPasses to the frame.
    EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
    EXPECT_EQ(1, frame.renderPasses[1]->id.index);
    EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
    EXPECT_EQ(2, frame.renderPasses[2]->id.index);

    // The DelegatedRendererLayer should have added copies of its quads to contributing RenderPasses.
    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
    EXPECT_RECT_EQ(gfx::Rect(0, 0, 6, 6), frame.renderPasses[1]->quad_list[0]->rect);

    // Verify it added the right quads.
    ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
    EXPECT_RECT_EQ(gfx::Rect(0, 0, 7, 7), frame.renderPasses[2]->quad_list[0]->rect);
    EXPECT_RECT_EQ(gfx::Rect(6, 6, 6, 6), frame.renderPasses[2]->quad_list[1]->rect);
    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
    EXPECT_RECT_EQ(gfx::Rect(0, 0, 6, 6), frame.renderPasses[1]->quad_list[0]->rect);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestOwnSurface, AddsQuadsToTargetRenderPass)
{
    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes and its owned surface added one pass.
    ASSERT_EQ(6u, frame.renderPasses.size());

    // The layer's target is the RenderPass owned by itself.
    EXPECT_EQ(RenderPass::Id(4, 0), frame.renderPasses[3]->id);

    // The DelegatedRendererLayer should have added copies of quads in its root RenderPass to its target RenderPass.
    // The m_layerAfter also adds one quad.
    ASSERT_EQ(1u, frame.renderPasses[3]->quad_list.size());

    // Verify it added the right quads.
    EXPECT_RECT_EQ(gfx::Rect(7, 7, 7, 7), frame.renderPasses[3]->quad_list[0]->rect);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestOwnSurface, QuadsFromRootRenderPassAreNotModifiedForTheTarget)
{
    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes and its owned surface added one pass.
    ASSERT_EQ(6u, frame.renderPasses.size());

    // Because the DelegatedRendererLayer owns a RenderSurfaceImpl, its root RenderPass' quads do not need to be
    // translated at all. However, they are scaled from the frame's size (8x8) to the layer's bounds (10x10).
    gfx::Transform transform;
    transform.Scale(10.0 / 8.0, 10.0 / 8.0);
    EXPECT_TRANSFORMATION_MATRIX_EQ(transform, frame.renderPasses[3]->quad_list[0]->quadTransform());

    // Quads from non-root RenderPasses should not be shifted either.
    ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[2]->quad_list[0]->quadTransform());
    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[2]->quad_list[1]->quadTransform());
    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[1]->quad_list[0]->quadTransform());

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

class DelegatedRendererLayerImplTestTransform : public DelegatedRendererLayerImplTest {
public:
    void setUpTest()
    {
        scoped_ptr<LayerImpl> rootLayer = LayerImpl::create(m_hostImpl->activeTree(), 1);
        scoped_ptr<DelegatedRendererLayerImpl> delegatedRendererLayer = DelegatedRendererLayerImpl::create(m_hostImpl->activeTree(), 2);

        m_hostImpl->setViewportSize(gfx::Size(100, 100), gfx::Size(100, 100));
        rootLayer->setBounds(gfx::Size(100, 100));

        delegatedRendererLayer->setPosition(gfx::Point(20, 20));
        delegatedRendererLayer->setBounds(gfx::Size(30, 30)); 
        delegatedRendererLayer->setContentBounds(gfx::Size(30, 30));
        delegatedRendererLayer->setDrawsContent(true);
        gfx::Transform transform;
        transform.Scale(2.0, 2.0);
        transform.Translate(8.0, 8.0);
        delegatedRendererLayer->setTransform(transform);

        ScopedPtrVector<RenderPass> delegatedRenderPasses;

        gfx::Rect childPassRect(20, 20, 7, 7);
        gfx::Transform childPassTransform;
        childPassTransform.Scale(0.8, 0.8);
        childPassTransform.Translate(9.0, 9.0);
        gfx::Rect childPassClipRect(21, 21, 3, 3);
        bool childPassClipped = false;

        {
            TestRenderPass* pass = addRenderPass(delegatedRenderPasses, RenderPass::Id(10, 7), childPassRect, gfx::Transform());
            MockQuadCuller quadSink(pass->quad_list, pass->shared_quad_state_list);
            AppendQuadsData data(pass->id);
            SharedQuadState* sharedState = quadSink.useSharedQuadState(SharedQuadState::Create());
            sharedState->SetAll(childPassTransform, childPassRect, childPassClipRect, childPassClipped, 1);
            scoped_ptr<SolidColorDrawQuad> colorQuad;

            colorQuad = SolidColorDrawQuad::Create();
            colorQuad->SetNew(sharedState, gfx::Rect(20, 20, 3, 7), 1u);
            quadSink.append(colorQuad.PassAs<DrawQuad>(), data);

            colorQuad = SolidColorDrawQuad::Create();
            colorQuad->SetNew(sharedState, gfx::Rect(23, 20, 4, 7), 1u);
            quadSink.append(colorQuad.PassAs<DrawQuad>(), data);
        }

        gfx::Rect passRect(0, 0, 50, 50);
        gfx::Transform passTransform;
        passTransform.Scale(1.5, 1.5);
        passTransform.Translate(7.0, 7.0);
        gfx::Rect passClipRect(10, 10, 35, 35);
        bool passClipped = m_rootDelegatedRenderPassIsClipped;

        TestRenderPass* pass = addRenderPass(delegatedRenderPasses, RenderPass::Id(9, 6), passRect, gfx::Transform());
        MockQuadCuller quadSink(pass->quad_list, pass->shared_quad_state_list);
        AppendQuadsData data(pass->id);
        SharedQuadState* sharedState = quadSink.useSharedQuadState(SharedQuadState::Create());
        sharedState->SetAll(passTransform, passRect, passClipRect, passClipped, 1);
        scoped_ptr<SolidColorDrawQuad> colorQuad;

        scoped_ptr<RenderPassDrawQuad> renderPassQuad = RenderPassDrawQuad::Create();
        renderPassQuad->SetNew(
            sharedState,
            gfx::Rect(5, 5, 7, 7),
            RenderPass::Id(10, 7),
            false, // is_replica
            0, // mask_resource_id
            childPassRect, // contents_changed_since_last_frame
            gfx::RectF(), // mask_uv_rect
            WebKit::WebFilterOperations(), // filters
            skia::RefPtr<SkImageFilter>(), // filter
            WebKit::WebFilterOperations()); // background_filters
        quadSink.append(renderPassQuad.PassAs<DrawQuad>(), data);

        colorQuad = SolidColorDrawQuad::Create();
        colorQuad->SetNew(sharedState, gfx::Rect(0, 0, 10, 10), 1u);
        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);

        colorQuad = SolidColorDrawQuad::Create();
        colorQuad->SetNew(sharedState, gfx::Rect(0, 10, 10, 10), 2u);
        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);

        colorQuad = SolidColorDrawQuad::Create();
        colorQuad->SetNew(sharedState, gfx::Rect(10, 0, 10, 10), 3u);
        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);

        colorQuad = SolidColorDrawQuad::Create();
        colorQuad->SetNew(sharedState, gfx::Rect(10, 10, 10, 10), 4u);
        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);

        delegatedRendererLayer->setRenderPasses(delegatedRenderPasses);

        // The RenderPasses should be taken by the layer.
        EXPECT_EQ(0u, delegatedRenderPasses.size());

        m_rootLayerPtr = rootLayer.get();
        m_delegatedRendererLayerPtr = delegatedRendererLayer.get();

        rootLayer->addChild(delegatedRendererLayer.PassAs<LayerImpl>());

        m_hostImpl->activeTree()->SetRootLayer(rootLayer.Pass());
    }

    void verifyRenderPasses(
        const LayerTreeHostImpl::FrameData& frame,
        size_t numRenderPasses,
        const SharedQuadState** rootSharedState,
        const SharedQuadState** contribSharedState)
    {
        ASSERT_EQ(numRenderPasses, frame.renderPasses.size());
        // The contributing render pass in the DelegatedRendererLayer.
        EXPECT_EQ(2, frame.renderPasses[0]->id.layer_id);
        EXPECT_EQ(1, frame.renderPasses[0]->id.index);
        // The root render pass.
        EXPECT_EQ(1, frame.renderPasses.back()->id.layer_id);
        EXPECT_EQ(0, frame.renderPasses.back()->id.index);

        const QuadList& contribQuadList = frame.renderPasses[0]->quad_list;
        ASSERT_EQ(2u, contribQuadList.size());

        const QuadList& rootQuadList = frame.renderPasses[1]->quad_list;
        ASSERT_EQ(5u, rootQuadList.size());

        // All quads in a render pass should share the same state.
        *contribSharedState = contribQuadList[0]->shared_quad_state;
        EXPECT_EQ(*contribSharedState, contribQuadList[1]->shared_quad_state);

        *rootSharedState = rootQuadList[0]->shared_quad_state;
        EXPECT_EQ(*rootSharedState, rootQuadList[1]->shared_quad_state);
        EXPECT_EQ(*rootSharedState, rootQuadList[2]->shared_quad_state);
        EXPECT_EQ(*rootSharedState, rootQuadList[3]->shared_quad_state);
        EXPECT_EQ(*rootSharedState, rootQuadList[4]->shared_quad_state);

        EXPECT_NE(*contribSharedState, *rootSharedState);
    }

protected:
    LayerImpl* m_rootLayerPtr;
    DelegatedRendererLayerImpl* m_delegatedRendererLayerPtr;
    bool m_rootDelegatedRenderPassIsClipped;
};

TEST_F(DelegatedRendererLayerImplTestTransform, QuadsUnclipped_NoSurface)
{
    m_rootDelegatedRenderPassIsClipped = false;
    setUpTest();

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    const SharedQuadState* rootSharedState = NULL;
    const SharedQuadState* contribSharedState = NULL;
    verifyRenderPasses(frame, 2, &rootSharedState, &contribSharedState);

    // When the quads don't have a clip of their own, the clip rect is set to
    // the drawableContentRect of the delegated renderer layer.
    EXPECT_RECT_EQ(gfx::Rect(21, 21, 60, 60), rootSharedState->clip_rect);

    // Even though the quads in the root pass have no clip of their own, they
    // inherit the clip rect from the delegated renderer layer if it does not
    // own a surface.
    EXPECT_TRUE(rootSharedState->is_clipped);

    gfx::Transform expected;
    // This is the transform from the layer's space to its target.
    // The position (20) - the width / scale (30 / 2) = 20 - 15 = 5
    expected.Translate(5.0, 5.0);
    expected.Scale(2.0, 2.0);
    expected.Translate(8.0, 8.0);
    // The frame has size 50x50 but the layer's bounds are 30x30.
    expected.Scale(30.0 / 50.0, 30.0 / 50.0);
    // This is the transform within the source frame.
    expected.Scale(1.5, 1.5);
    expected.Translate(7.0, 7.0);
    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, rootSharedState->content_to_target_transform);

    // The contributing render pass should not be transformed from its input.
    EXPECT_RECT_EQ(gfx::Rect(21, 21, 3, 3), contribSharedState->clip_rect);
    EXPECT_FALSE(contribSharedState->is_clipped);
    expected.MakeIdentity();
    expected.Scale(0.8, 0.8);
    expected.Translate(9.0, 9.0);
    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, contribSharedState->content_to_target_transform);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestTransform, QuadsClipped_NoSurface)
{
    m_rootDelegatedRenderPassIsClipped = true;
    setUpTest();

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    const SharedQuadState* rootSharedState = NULL;
    const SharedQuadState* contribSharedState = NULL;
    verifyRenderPasses(frame, 2, &rootSharedState, &contribSharedState);

    // Since the quads have a clip_rect it should be modified by delegated
    // renderer layer's drawTransform.
    // The position of the resulting clip_rect is:
    // (clip rect position (10) * scale to layer (30/50) + translate (8)) * layer scale (2) + layer position (20) = 48
    // 48 - (width / 2) = 48 - 30 / 2 = 33
    // The size is 35x35 scaled to fit inside the layer's bounds at 30x30 from
    // a frame at 50x50:
    // 35 * 2 (layer's scale) * 30 / 50 = 42.
    EXPECT_RECT_EQ(gfx::Rect(33, 33, 42, 42), rootSharedState->clip_rect);

    // The quads had a clip and it should be preserved.
    EXPECT_TRUE(rootSharedState->is_clipped);

    gfx::Transform expected;
    // This is the transform from the layer's space to its target.
    // The position (20) - the width / scale (30 / 2) = 20 - 15 = 5
    expected.Translate(5.0, 5.0);
    expected.Scale(2.0, 2.0);
    expected.Translate(8.0, 8.0);
    // The frame has size 50x50 but the layer's bounds are 30x30.
    expected.Scale(30.0 / 50.0, 30.0 / 50.0);
    // This is the transform within the source frame.
    expected.Scale(1.5, 1.5);
    expected.Translate(7.0, 7.0);
    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, rootSharedState->content_to_target_transform);

    // The contributing render pass should not be transformed from its input.
    EXPECT_RECT_EQ(gfx::Rect(21, 21, 3, 3), contribSharedState->clip_rect);
    EXPECT_FALSE(contribSharedState->is_clipped);
    expected.MakeIdentity();
    expected.Scale(0.8, 0.8);
    expected.Translate(9.0, 9.0);
    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, contribSharedState->content_to_target_transform);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestTransform, QuadsUnclipped_Surface)
{
    m_rootDelegatedRenderPassIsClipped = false;
    setUpTest();

    m_delegatedRendererLayerPtr->setForceRenderSurface(true);

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    const SharedQuadState* rootSharedState = NULL;
    const SharedQuadState* contribSharedState = NULL;
    verifyRenderPasses(frame, 3, &rootSharedState, &contribSharedState);

    // When the layer owns a surface, then its position and translation are not
    // a part of its draw transform.
    // The position of the resulting clip_rect is:
    // (clip rect position (10) * scale to layer (30/50)) * layer scale (2) = 12
    // The size is 35x35 scaled to fit inside the layer's bounds at 30x30 from
    // a frame at 50x50:
    // 35 * 2 (layer's scale) * 30 / 50 = 42.
    EXPECT_RECT_EQ(gfx::Rect(12, 12, 42, 42), rootSharedState->clip_rect);

    // Since the layer owns a surface it doesn't need to clip its quads, so
    // unclipped quads remain unclipped.
    EXPECT_FALSE(rootSharedState->is_clipped);

    gfx::Transform expected;
    expected.Scale(2.0, 2.0);
    // The frame has size 50x50 but the layer's bounds are 30x30.
    expected.Scale(30.0 / 50.0, 30.0 / 50.0);
    // This is the transform within the source frame.
    expected.Scale(1.5, 1.5);
    expected.Translate(7.0, 7.0);
    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, rootSharedState->content_to_target_transform);

    // The contributing render pass should not be transformed from its input.
    EXPECT_RECT_EQ(gfx::Rect(21, 21, 3, 3), contribSharedState->clip_rect);
    EXPECT_FALSE(contribSharedState->is_clipped);
    expected.MakeIdentity();
    expected.Scale(0.8, 0.8);
    expected.Translate(9.0, 9.0);
    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, contribSharedState->content_to_target_transform);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestTransform, QuadsClipped_Surface)
{
    m_rootDelegatedRenderPassIsClipped = true;
    setUpTest();

    m_delegatedRendererLayerPtr->setForceRenderSurface(true);

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    const SharedQuadState* rootSharedState = NULL;
    const SharedQuadState* contribSharedState = NULL;
    verifyRenderPasses(frame, 3, &rootSharedState, &contribSharedState);

    // When the layer owns a surface, then its position and translation are not
    // a part of its draw transform.
    // The position of the resulting clip_rect is:
    // (clip rect position (10) * scale to layer (30/50)) * layer scale (2) = 12
    // The size is 35x35 scaled to fit inside the layer's bounds at 30x30 from
    // a frame at 50x50:
    // 35 * 2 (layer's scale) * 30 / 50 = 42.
    EXPECT_RECT_EQ(gfx::Rect(12, 12, 42, 42), rootSharedState->clip_rect);

    // The quads had a clip and it should be preserved.
    EXPECT_TRUE(rootSharedState->is_clipped);

    gfx::Transform expected;
    expected.Scale(2.0, 2.0);
    // The frame has size 50x50 but the layer's bounds are 30x30.
    expected.Scale(30.0 / 50.0, 30.0 / 50.0);
    // This is the transform within the source frame.
    expected.Scale(1.5, 1.5);
    expected.Translate(7.0, 7.0);
    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, rootSharedState->content_to_target_transform);

    // The contributing render pass should not be transformed from its input.
    EXPECT_RECT_EQ(gfx::Rect(21, 21, 3, 3), contribSharedState->clip_rect);
    EXPECT_FALSE(contribSharedState->is_clipped);
    expected.MakeIdentity();
    expected.Scale(0.8, 0.8);
    expected.Translate(9.0, 9.0);
    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, contribSharedState->content_to_target_transform);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

class DelegatedRendererLayerImplTestClip : public DelegatedRendererLayerImplTest {
public:
    void setUpTest()
    {
        scoped_ptr<LayerImpl> rootLayer = LayerImpl::create(m_hostImpl->activeTree(), 1);
        scoped_ptr<DelegatedRendererLayerImpl> delegatedRendererLayer = DelegatedRendererLayerImpl::create(m_hostImpl->activeTree(), 2);
        scoped_ptr<LayerImpl> clipLayer = LayerImpl::create(m_hostImpl->activeTree(), 3);
        scoped_ptr<LayerImpl> originLayer = LayerImpl::create(m_hostImpl->activeTree(), 4);

        m_hostImpl->setViewportSize(gfx::Size(100, 100), gfx::Size(100, 100));
        rootLayer->setBounds(gfx::Size(100, 100));

        delegatedRendererLayer->setPosition(gfx::Point(20, 20));
        delegatedRendererLayer->setBounds(gfx::Size(50, 50)); 
        delegatedRendererLayer->setContentBounds(gfx::Size(50, 50));
        delegatedRendererLayer->setDrawsContent(true);

        ScopedPtrVector<RenderPass> delegatedRenderPasses;

        gfx::Rect childPassRect(20, 20, 7, 7);
        gfx::Transform childPassTransform;
        gfx::Rect childPassClipRect(21, 21, 3, 3);
        bool childPassClipped = false;

        {
            TestRenderPass* pass = addRenderPass(delegatedRenderPasses, RenderPass::Id(10, 7), childPassRect, gfx::Transform());
            MockQuadCuller quadSink(pass->quad_list, pass->shared_quad_state_list);
            AppendQuadsData data(pass->id);
            SharedQuadState* sharedState = quadSink.useSharedQuadState(SharedQuadState::Create());
            sharedState->SetAll(childPassTransform, childPassRect, childPassClipRect, childPassClipped, 1);
            scoped_ptr<SolidColorDrawQuad> colorQuad;

            colorQuad = SolidColorDrawQuad::Create();
            colorQuad->SetNew(sharedState, gfx::Rect(20, 20, 3, 7), 1u);
            quadSink.append(colorQuad.PassAs<DrawQuad>(), data);

            colorQuad = SolidColorDrawQuad::Create();
            colorQuad->SetNew(sharedState, gfx::Rect(23, 20, 4, 7), 1u);
            quadSink.append(colorQuad.PassAs<DrawQuad>(), data);
        }

        gfx::Rect passRect(0, 0, 50, 50);
        gfx::Transform passTransform;
        gfx::Rect passClipRect(5, 5, 40, 40);
        bool passClipped = m_rootDelegatedRenderPassIsClipped;

        TestRenderPass* pass = addRenderPass(delegatedRenderPasses, RenderPass::Id(9, 6), passRect, gfx::Transform());
        MockQuadCuller quadSink(pass->quad_list, pass->shared_quad_state_list);
        AppendQuadsData data(pass->id);
        SharedQuadState* sharedState = quadSink.useSharedQuadState(SharedQuadState::Create());
        sharedState->SetAll(passTransform, passRect, passClipRect, passClipped, 1);
        scoped_ptr<SolidColorDrawQuad> colorQuad;

        scoped_ptr<RenderPassDrawQuad> renderPassQuad = RenderPassDrawQuad::Create();
        renderPassQuad->SetNew(
            sharedState,
            gfx::Rect(5, 5, 7, 7),
            RenderPass::Id(10, 7),
            false, // is_replica
            0, // mask_resource_id
            childPassRect, // contents_changed_since_last_frame
            gfx::RectF(), // mask_uv_rect
            WebKit::WebFilterOperations(), // filters
            skia::RefPtr<SkImageFilter>(), // filter
            WebKit::WebFilterOperations()); // background_filters
        quadSink.append(renderPassQuad.PassAs<DrawQuad>(), data);

        colorQuad = SolidColorDrawQuad::Create();
        colorQuad->SetNew(sharedState, gfx::Rect(0, 0, 10, 10), 1u);
        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);

        colorQuad = SolidColorDrawQuad::Create();
        colorQuad->SetNew(sharedState, gfx::Rect(0, 10, 10, 10), 2u);
        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);

        colorQuad = SolidColorDrawQuad::Create();
        colorQuad->SetNew(sharedState, gfx::Rect(10, 0, 10, 10), 3u);
        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);

        colorQuad = SolidColorDrawQuad::Create();
        colorQuad->SetNew(sharedState, gfx::Rect(10, 10, 10, 10), 4u);
        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);

        delegatedRendererLayer->setRenderPasses(delegatedRenderPasses);

        // The RenderPasses should be taken by the layer.
        EXPECT_EQ(0u, delegatedRenderPasses.size());

        m_rootLayerPtr = rootLayer.get();
        m_delegatedRendererLayerPtr = delegatedRendererLayer.get();

        if (m_clipDelegatedRendererLayer) {
            gfx::Rect clipRect(21, 27, 23, 21);

            clipLayer->setPosition(clipRect.origin());
            clipLayer->setBounds(clipRect.size());
            clipLayer->setContentBounds(clipRect.size());
            clipLayer->setMasksToBounds(true);
            clipLayer->setAnchorPoint(gfx::PointF());

            originLayer->setPosition(gfx::PointAtOffsetFromOrigin(-clipRect.OffsetFromOrigin()));
            originLayer->setAnchorPoint(gfx::PointF());

            originLayer->addChild(delegatedRendererLayer.PassAs<LayerImpl>());
            clipLayer->addChild(originLayer.Pass());
            rootLayer->addChild(clipLayer.Pass());
        } else {
            rootLayer->addChild(delegatedRendererLayer.PassAs<LayerImpl>());
        }

        m_hostImpl->activeTree()->SetRootLayer(rootLayer.Pass());
    }

protected:
    LayerImpl* m_rootLayerPtr;
    DelegatedRendererLayerImpl* m_delegatedRendererLayerPtr;
    bool m_rootDelegatedRenderPassIsClipped;
    bool m_clipDelegatedRendererLayer;
};

TEST_F(DelegatedRendererLayerImplTestClip, QuadsUnclipped_LayerUnclipped_NoSurface)
{
    m_rootDelegatedRenderPassIsClipped = false;
    m_clipDelegatedRendererLayer = false;
    setUpTest();

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    ASSERT_EQ(2u, frame.renderPasses.size());
    const QuadList& contribQuadList = frame.renderPasses[0]->quad_list;
    ASSERT_EQ(2u, contribQuadList.size());
    const QuadList& rootQuadList = frame.renderPasses[1]->quad_list;
    ASSERT_EQ(5u, rootQuadList.size());
    const SharedQuadState* rootSharedState = rootQuadList[0]->shared_quad_state;
    const SharedQuadState* contribSharedState = contribQuadList[0]->shared_quad_state;

    // When the quads don't have a clip of their own, the clip rect is set to
    // the drawableContentRect of the delegated renderer layer.
    EXPECT_RECT_EQ(gfx::Rect(20, 20, 50, 50), rootSharedState->clip_rect);
    // Quads are clipped to the delegated renderer layer.
    EXPECT_TRUE(rootSharedState->is_clipped);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestClip, QuadsClipped_LayerUnclipped_NoSurface)
{
    m_rootDelegatedRenderPassIsClipped = true;
    m_clipDelegatedRendererLayer = false;
    setUpTest();

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    ASSERT_EQ(2u, frame.renderPasses.size());
    const QuadList& contribQuadList = frame.renderPasses[0]->quad_list;
    ASSERT_EQ(2u, contribQuadList.size());
    const QuadList& rootQuadList = frame.renderPasses[1]->quad_list;
    ASSERT_EQ(5u, rootQuadList.size());
    const SharedQuadState* rootSharedState = rootQuadList[0]->shared_quad_state;
    const SharedQuadState* contribSharedState = contribQuadList[0]->shared_quad_state;

    // When the quads have a clip of their own, it is used.
    EXPECT_RECT_EQ(gfx::Rect(25, 25, 40, 40), rootSharedState->clip_rect);
    // Quads came with a clip rect.
    EXPECT_TRUE(rootSharedState->is_clipped);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestClip, QuadsUnclipped_LayerClipped_NoSurface)
{
    m_rootDelegatedRenderPassIsClipped = false;
    m_clipDelegatedRendererLayer = true;
    setUpTest();

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    ASSERT_EQ(2u, frame.renderPasses.size());
    const QuadList& contribQuadList = frame.renderPasses[0]->quad_list;
    ASSERT_EQ(2u, contribQuadList.size());
    const QuadList& rootQuadList = frame.renderPasses[1]->quad_list;
    ASSERT_EQ(5u, rootQuadList.size());
    const SharedQuadState* rootSharedState = rootQuadList[0]->shared_quad_state;
    const SharedQuadState* contribSharedState = contribQuadList[0]->shared_quad_state;

    // When the quads don't have a clip of their own, the clip rect is set to
    // the drawableContentRect of the delegated renderer layer. When the layer
    // is clipped, that should be seen in the quads' clip_rect.
    EXPECT_RECT_EQ(gfx::Rect(21, 27, 23, 21), rootSharedState->clip_rect);
    // Quads are clipped to the delegated renderer layer.
    EXPECT_TRUE(rootSharedState->is_clipped);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestClip, QuadsClipped_LayerClipped_NoSurface)
{
    m_rootDelegatedRenderPassIsClipped = true;
    m_clipDelegatedRendererLayer = true;
    setUpTest();

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    ASSERT_EQ(2u, frame.renderPasses.size());
    const QuadList& contribQuadList = frame.renderPasses[0]->quad_list;
    ASSERT_EQ(2u, contribQuadList.size());
    const QuadList& rootQuadList = frame.renderPasses[1]->quad_list;
    ASSERT_EQ(5u, rootQuadList.size());
    const SharedQuadState* rootSharedState = rootQuadList[0]->shared_quad_state;
    const SharedQuadState* contribSharedState = contribQuadList[0]->shared_quad_state;

    // When the quads have a clip of their own, it is used, but it is
    // combined with the clip rect of the delegated renderer layer.
    EXPECT_RECT_EQ(gfx::Rect(25, 27, 19, 21), rootSharedState->clip_rect);
    // Quads came with a clip rect.
    EXPECT_TRUE(rootSharedState->is_clipped);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestClip, QuadsUnclipped_LayerUnclipped_Surface)
{
    m_rootDelegatedRenderPassIsClipped = false;
    m_clipDelegatedRendererLayer = false;
    setUpTest();

    m_delegatedRendererLayerPtr->setForceRenderSurface(true);

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    ASSERT_EQ(3u, frame.renderPasses.size());
    const QuadList& contribQuadList = frame.renderPasses[0]->quad_list;
    ASSERT_EQ(2u, contribQuadList.size());
    const QuadList& rootQuadList = frame.renderPasses[1]->quad_list;
    ASSERT_EQ(5u, rootQuadList.size());
    const SharedQuadState* rootSharedState = rootQuadList[0]->shared_quad_state;
    const SharedQuadState* contribSharedState = contribQuadList[0]->shared_quad_state;

    // When the layer owns a surface, the quads don't need to be clipped
    // further than they already specify. If they aren't clipped, then their
    // clip rect is ignored, and they are not set as clipped.
    EXPECT_FALSE(rootSharedState->is_clipped);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestClip, QuadsClipped_LayerUnclipped_Surface)
{
    m_rootDelegatedRenderPassIsClipped = true;
    m_clipDelegatedRendererLayer = false;
    setUpTest();

    m_delegatedRendererLayerPtr->setForceRenderSurface(true);

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    ASSERT_EQ(3u, frame.renderPasses.size());
    const QuadList& contribQuadList = frame.renderPasses[0]->quad_list;
    ASSERT_EQ(2u, contribQuadList.size());
    const QuadList& rootQuadList = frame.renderPasses[1]->quad_list;
    ASSERT_EQ(5u, rootQuadList.size());
    const SharedQuadState* rootSharedState = rootQuadList[0]->shared_quad_state;
    const SharedQuadState* contribSharedState = contribQuadList[0]->shared_quad_state;

    // When the quads have a clip of their own, it is used.
    EXPECT_RECT_EQ(gfx::Rect(5, 5, 40, 40), rootSharedState->clip_rect);
    // Quads came with a clip rect.
    EXPECT_TRUE(rootSharedState->is_clipped);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestClip, QuadsUnclipped_LayerClipped_Surface)
{
    m_rootDelegatedRenderPassIsClipped = false;
    m_clipDelegatedRendererLayer = true;
    setUpTest();

    m_delegatedRendererLayerPtr->setForceRenderSurface(true);

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    ASSERT_EQ(3u, frame.renderPasses.size());
    const QuadList& contribQuadList = frame.renderPasses[0]->quad_list;
    ASSERT_EQ(2u, contribQuadList.size());
    const QuadList& rootQuadList = frame.renderPasses[1]->quad_list;
    ASSERT_EQ(5u, rootQuadList.size());
    const SharedQuadState* rootSharedState = rootQuadList[0]->shared_quad_state;
    const SharedQuadState* contribSharedState = contribQuadList[0]->shared_quad_state;

    // When the layer owns a surface, the quads don't need to be clipped
    // further than they already specify. If they aren't clipped, then their
    // clip rect is ignored, and they are not set as clipped.
    EXPECT_FALSE(rootSharedState->is_clipped);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

TEST_F(DelegatedRendererLayerImplTestClip, QuadsClipped_LayerClipped_Surface)
{
    m_rootDelegatedRenderPassIsClipped = true;
    m_clipDelegatedRendererLayer = true;
    setUpTest();

    m_delegatedRendererLayerPtr->setForceRenderSurface(true);

    LayerTreeHostImpl::FrameData frame;
    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));

    ASSERT_EQ(3u, frame.renderPasses.size());
    const QuadList& contribQuadList = frame.renderPasses[0]->quad_list;
    ASSERT_EQ(2u, contribQuadList.size());
    const QuadList& rootQuadList = frame.renderPasses[1]->quad_list;
    ASSERT_EQ(5u, rootQuadList.size());
    const SharedQuadState* rootSharedState = rootQuadList[0]->shared_quad_state;
    const SharedQuadState* contribSharedState = contribQuadList[0]->shared_quad_state;

    // When the quads have a clip of their own, it is used, but it is
    // combined with the clip rect of the delegated renderer layer. If the
    // layer owns a surface, then it does not have a clip rect of its own.
    EXPECT_RECT_EQ(gfx::Rect(5, 5, 40, 40), rootSharedState->clip_rect);
    // Quads came with a clip rect.
    EXPECT_TRUE(rootSharedState->is_clipped);

    m_hostImpl->drawLayers(frame);
    m_hostImpl->didDrawAllLayers(frame);
}

}  // namespace
}  // namespace cc
